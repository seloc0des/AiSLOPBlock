# NoAI Slop Cleaner (Chromium Extension) — MVP + Roadmap

This document exports the full content of the previous generation (MVP architecture + working Manifest V3 extension skeleton) into a single Markdown file you can drop into your IDE.

---

## What’s realistically detectable

- **“AI ads”** are usually ads whose *creative* is AI-themed. You can target them reliably by detecting **ad containers** + **AI keywords**.
- **“AI slop”** (AI-generated low-quality pages) can’t be detected perfectly without heavy ML, so the practical approach is:
  1) **Block/Down-rank known slop domains** (a community list, like adblock lists), and  
  2) **Hide AI-labeled content** (“AI-generated”, “written by AI”, etc.), and  
  3) Add **site-specific cleaners** (Google/Bing/YouTube/etc).

---

## Recommended build: 2-layer “No AI Slop” extension

### Layer A — Network blocking (fast, strong)

Use **declarativeNetRequest (DNR)** rules to block:
- known AI content-farm domains (your “slop list”)
- known “AI ad” click trackers / landing domains (optional)
- obvious “AI widget” endpoints if they’re consistent (often not)

### Layer B — DOM hiding (what users actually *see*)

A content script runs at `document_start`, injects CSS to hide known AI UI, and uses a **MutationObserver** to catch:
- “Sponsored/Ad/Promoted” blocks that contain AI keywords
- “AI-generated” disclosures
- site-specific AI UI containers (AI answer boxes, “Ask AI” panels, etc.)

---

## MVP you can paste into a folder and load unpacked

### Folder layout

```text
noai/
  manifest.json
  sw.js
  content.js
  ui/
    popup.html
    popup.js
    options.html
    options.js
```

---

## `manifest.json`

```json
{
  "manifest_version": 3,
  "name": "NoAI Slop Cleaner",
  "version": "0.1.0",
  "description": "Hides AI panels and AI-themed ads, and blocks known AI-slop domains.",
  "permissions": ["storage", "declarativeNetRequest"],
  "host_permissions": ["<all_urls>"],
  "background": { "service_worker": "sw.js", "type": "module" },
  "action": { "default_popup": "ui/popup.html" },
  "options_page": "ui/options.html",
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"],
      "run_at": "document_start"
    }
  ]
}
```

---

## `sw.js` (service worker)

- stores defaults on install
- updates the toolbar badge with “hidden count” per tab
- (optional) you can later add DNR dynamic domain blocking here

```js
const DEFAULTS = {
  enabled: true,
  aiKeywords: [
    "ai", "artificial intelligence", "chatgpt", "gpt", "copilot", "prompt",
    "llm", "generative", "midjourney", "stable diffusion"
  ],
  disclosurePhrases: [
    "ai-generated", "generated by ai", "written by ai", "created with ai"
  ],
  adPhrases: ["sponsored", "promoted", "ad", "paid partnership"],
  disabledHosts: [],
  perSiteEnabled: {} // host -> boolean
};

const hiddenCountByTab = new Map();

chrome.runtime.onInstalled.addListener(async () => {
  const existing = await chrome.storage.sync.get(Object.keys(DEFAULTS));
  const toSet = {};
  for (const [k, v] of Object.entries(DEFAULTS)) {
    if (existing[k] === undefined) toSet[k] = v;
  }
  if (Object.keys(toSet).length) await chrome.storage.sync.set(toSet);
});

chrome.runtime.onMessage.addListener((msg, sender) => {
  if (!sender.tab?.id) return;
  const tabId = sender.tab.id;

  if (msg?.type === "noai:hidden-inc") {
    const next = (hiddenCountByTab.get(tabId) || 0) + (msg.amount || 1);
    hiddenCountByTab.set(tabId, next);
    chrome.action.setBadgeText({ tabId, text: String(next) });
    chrome.action.setBadgeBackgroundColor({ tabId, color: "#444" });
  }

  if (msg?.type === "noai:reset") {
    hiddenCountByTab.set(tabId, 0);
    chrome.action.setBadgeText({ tabId, text: "" });
  }
});

chrome.tabs.onRemoved.addListener((tabId) => {
  hiddenCountByTab.delete(tabId);
});
```

---

## `content.js` (DOM cleaner)

This is the “AI ads + AI labeled content” remover.

```js
const STOP_WORDS_MIN_LEN = 2;

function norm(s) {
  return (s || "").toLowerCase().trim();
}

function containsAny(haystack, needles) {
  const h = norm(haystack);
  for (const n of needles) {
    const nn = norm(n);
    if (nn.length >= STOP_WORDS_MIN_LEN && h.includes(nn)) return true;
  }
  return false;
}

function isProbablyAdContainer(el, adPhrases) {
  // Heuristic: common ad-ish signals
  const aria = el.getAttribute?.("aria-label") || "";
  const role = el.getAttribute?.("role") || "";
  const idc = `${el.id || ""} ${el.className || ""}`;

  if (containsAny(aria, adPhrases)) return true;
  if (containsAny(role, ["banner", "complementary"])) return true;
  if (containsAny(idc, ["ad", "ads", "sponsor", "promoted", "promotion"])) return true;

  // Text marker is common on search/social cards:
  const text = el.innerText || "";
  if (containsAny(text, adPhrases)) return true;

  return false;
}

function hide(el) {
  if (!el || el.nodeType !== 1) return false;
  if (el.dataset?.noaiHidden === "1") return false;
  el.dataset.noaiHidden = "1";
  el.style.setProperty("display", "none", "important");
  return true;
}

(async function main() {
  const host = location.hostname;

  const {
    enabled,
    aiKeywords,
    disclosurePhrases,
    adPhrases,
    disabledHosts,
    perSiteEnabled
  } = await chrome.storage.sync.get([
    "enabled",
    "aiKeywords",
    "disclosurePhrases",
    "adPhrases",
    "disabledHosts",
    "perSiteEnabled"
  ]);

  if (!enabled) return;
  if ((disabledHosts || []).includes(host)) return;
  if (perSiteEnabled && perSiteEnabled[host] === false) return;

  chrome.runtime.sendMessage({ type: "noai:reset" });

  // Quick CSS pass for obvious AI labels/classes used by some sites
  const style = document.createElement("style");
  style.textContent = `
    /* Generic AI labels (best-effort) */
    [data-ai], .ai-generated, .ai-content, .generated-by-ai { display:none !important; }
  `;
  document.documentElement.appendChild(style);

  function scanNode(node) {
    if (!node || node.nodeType !== 1) return;
    const el = /** @type {Element} */ (node);

    // 1) Hide disclosure blocks (AI-generated labels, etc.)
    const txt = el.innerText || "";
    if (containsAny(txt, disclosurePhrases)) {
      if (hide(el)) chrome.runtime.sendMessage({ type: "noai:hidden-inc" });
      return;
    }

    // 2) Hide AI-themed ads: (ad container) AND (AI keyword)
    // Check element itself OR a nearby container (closest parent div/section/article)
    const container = el.closest?.("article, section, div, li") || el;
    if (isProbablyAdContainer(container, adPhrases) && containsAny(container.innerText || "", aiKeywords)) {
      if (hide(container)) chrome.runtime.sendMessage({ type: "noai:hidden-inc" });
      return;
    }

    // 3) Domain-level slop hiding (optional heuristic):
    // If a card links to a known slop domain, you can hide the card.
    // (Leave for v0.2 when you add a domain list + matching)
  }

  // Initial scan (lightweight)
  document.querySelectorAll("article, section, div, li").forEach(scanNode);

  // Observe future content (infinite scroll, SPA rendering)
  const obs = new MutationObserver((mutations) => {
    for (const m of mutations) {
      for (const n of m.addedNodes) {
        scanNode(n);
        if (n?.querySelectorAll) n.querySelectorAll("article, section, div, li").forEach(scanNode);
      }
    }
  });

  obs.observe(document.documentElement, { childList: true, subtree: true });
})();
```

---

## `ui/popup.html`

```html
<!doctype html>
<html>
  <head><meta charset="utf-8" /><style>
    body { font: 13px system-ui, sans-serif; margin: 12px; width: 260px; }
    .row { display:flex; align-items:center; justify-content:space-between; margin: 8px 0; }
    button { width: 100%; padding: 8px; }
  </style></head>
  <body>
    <div class="row">
      <div>Enabled</div>
      <input id="enabled" type="checkbox" />
    </div>
    <button id="disableSite">Disable on this site</button>
    <script src="popup.js"></script>
  </body>
</html>
```

---

## `ui/popup.js`

```js
(async function () {
  const { enabled = true } = await chrome.storage.sync.get(["enabled"]);
  const checkbox = document.getElementById("enabled");
  checkbox.checked = enabled;

  checkbox.addEventListener("change", async () => {
    await chrome.storage.sync.set({ enabled: checkbox.checked });
  });

  document.getElementById("disableSite").addEventListener("click", async () => {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    const url = new URL(tab.url);
    const host = url.hostname;

    const { disabledHosts = [] } = await chrome.storage.sync.get(["disabledHosts"]);
    if (!disabledHosts.includes(host)) disabledHosts.push(host);
    await chrome.storage.sync.set({ disabledHosts });
    window.close();
  });
})();
```

---

## `ui/options.html`

```html
<!doctype html>
<html>
  <head><meta charset="utf-8" /><style>
    body { font: 14px system-ui, sans-serif; margin: 16px; max-width: 800px; }
    textarea { width: 100%; min-height: 120px; }
    .grid { display:grid; gap: 12px; }
    button { padding: 10px 12px; width: fit-content; }
  </style></head>
  <body>
    <h2>NoAI Slop Cleaner – Settings</h2>
    <div class="grid">
      <label>AI keywords (one per line)</label>
      <textarea id="aiKeywords"></textarea>

      <label>Disclosure phrases to remove (one per line)</label>
      <textarea id="disclosurePhrases"></textarea>

      <label>Ad marker phrases (one per line)</label>
      <textarea id="adPhrases"></textarea>

      <button id="save">Save</button>
    </div>
    <script src="options.js"></script>
  </body>
</html>
```

---

## `ui/options.js`

```js
function linesToList(s) {
  return s.split("\n").map(x => x.trim()).filter(Boolean);
}

function listToLines(arr) {
  return (arr || []).join("\n");
}

(async function () {
  const els = {
    aiKeywords: document.getElementById("aiKeywords"),
    disclosurePhrases: document.getElementById("disclosurePhrases"),
    adPhrases: document.getElementById("adPhrases")
  };

  const data = await chrome.storage.sync.get(["aiKeywords", "disclosurePhrases", "adPhrases"]);
  els.aiKeywords.value = listToLines(data.aiKeywords);
  els.disclosurePhrases.value = listToLines(data.disclosurePhrases);
  els.adPhrases.value = listToLines(data.adPhrases);

  document.getElementById("save").addEventListener("click", async () => {
    await chrome.storage.sync.set({
      aiKeywords: linesToList(els.aiKeywords.value),
      disclosurePhrases: linesToList(els.disclosurePhrases.value),
      adPhrases: linesToList(els.adPhrases.value)
    });
    alert("Saved.");
  });
})();
```

---

## Load the extension (unpacked)

Chrome/Brave/Edge → **Extensions** → **Developer mode** → **Load unpacked** → select the `noai/` folder.

---

## What I’d add next (the part that makes it really good)

1) **DNR dynamic domain list (“slop domains”)**
   - A simple text list (`domain.tld` per line)
   - Convert to `chrome.declarativeNetRequest.updateDynamicRules()` rules
   - Support large safe-rule sets (far more than a small static list)

2) **Site modules**
   - `cleaners/google.js` → hide AI answer boxes / AI panels
   - `cleaners/facebook.js` → hide “Suggested for you” / “Sponsored” items when AI keywords match
   - `cleaners/news.js` → hide AI summary widgets / “AI-generated” labels

3) **Better “ad container” detection**
   - On many sites, ads are marked with `aria-label`, `data-testid`, or “Sponsored” badges.
   - Combine that with AI keywords and you’ll nail “AI advertisements” with low false positives.

4) **User controls**
   - “Show hidden items” button for the current page (soft-hide via CSS class instead of `display:none` inline)
   - Per-site toggles and quick whitelisting

5) **Publishing**
   - Manifest V3 requires all code shipped in-package (no remotely hosted JS).
   - If you fetch remote lists, treat them strictly as **data**, not executable code.

---

# Addendum (requested focus): Google Results, Facebook, News Sites

Below are **practical** next steps for those “usual suspects” without overfitting:

## Google Results (SERP)
- Primary strategy: **hide AI panels** and **AI-labeled blocks**.
- Secondary strategy: hide ads that contain AI keywords (rare but happens).

Implementation note:
- Google’s DOM changes often. Keep selectors **isolated** in `cleaners/google.js` and guard them with `location.hostname`.

## Facebook
- Primary strategy: detect “Sponsored”/“Suggested for you” containers and then apply keyword matching for AI terms.
- Use MutationObserver aggressively (FB is highly dynamic).

## News sites
- Primary strategy: remove “AI summary” widgets / “Ask AI” sidebars.
- Secondary: hide disclosure text like “generated by AI” or “AI-assisted”.

---

## Suggested structure for site-specific cleaners (v0.2)

```text
noai/
  cleaners/
    google.js
    facebook.js
    news_generic.js
```

You can conditionally load those from `content.js` by checking hostname and calling the appropriate function(s).
